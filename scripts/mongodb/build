#!/bin/bash -e
# build: Compile MongoDB

# Default project locations
mongodir="$HOME/code/mongo"
enterprisedir="$HOME/code/enterprise-modules"
moduledir="$mongodir/src/mongo/db/modules"
cachedir="$mongodir/build/scons/cache"

# Tuning knobs and the like
asan=0
cache=1
compiler=1
debug=0
dryrun=0
dynamic=0
enterprise=0
ssl=0
verbose=0
werror=1

# "version less than" -- compare if semantic version is less than another
verlt() {
    python -c "import sys
v1 = tuple('$1'.split('.'))
v2 = tuple('$2'.split('.'))
if v1 < v2:
    sys.exit(0)
else:
    sys.exit(1)"
}

options="adeghnsvw"
while getopts $options opt; do
    case "$opt" in
        a)
            symbolizer=$(which llvm-symbolizer-3.6 2>/dev/null)
            if [ -z $symbolizer ]; then
                echo "Fatal: no llvm-symbolizer found in path; ASAN unsupported"
                exit 4
            fi

            asan=1
            debug=1
            ;;
        d)
            dynamic=1
            ;;
        e)
            enterprise=1
            ;;
        g)
            debug=1
            ;;
        h)
            echo "Usage: $(basename $0) [-$options] [TARGETS ...]"
            echo "Available options:

    -a       Enable the address sanitizer (ASAN). Implies -g
    -d       Use dynamic linking to build shared libraries
    -e       Build with enterprise modules
    -g       Build in debug mode and disable optimization
    -h       Show this help message and exit
    -n       Dry run: print command but don't actually run anything
    -s       Enable SSL
    -v       Verbose output
    -w       Disable warnings as errors"
            exit 0
            ;;
        n)
            dryrun=1
            ;;
        s)
            ssl=1
            ;;
        v)
            verbose=1
            ;;
        w)
            werror=0
            ;;
        *)
            echo "Unrecognized option: -$opt"
            exit 1
            ;;
    esac
done
shift $((OPTIND-1))

# What version of MongoDB are we compiling?
version=$(git -C $mongodir describe --abbrev=0 2>/dev/null | tr -d "[r]")
if [ -z $version ]; then
    echo "Fatal: cannot do git describe in $mongodir"
    exit 2
fi

# Determine available compilers
clang=$(which clang 2>/dev/null)
clangxx=$(which clang++ 2>/dev/null)
if [ -d /opt/mongodbtoolchain ]; then
    # Running on Linux
    gcc=/opt/mongodbtoolchain/v2/bin/gcc
    gxx=/opt/mongodbtoolchain/v2/bin/g++
else
    gcc=$(which gcc 2>/dev/null)
    gxx=$(which g++ 2>/dev/null)
fi

# Bail if no compilers found
if [ -z $gcc ] && [ -z $clang ]; then
    echo "Fatal: neither GCC nor Clang was found on this system"
    exit 3
fi

# Cache options and number of jobs
if [ -e /proc/cpuinfo ]; then
    # On Linux
    cpus=$(grep -c processor /proc/cpuinfo)
    threads=$[cpus*2]
    linux=1
else
    # On Mac OS X
    threads=$(sysctl -n hw.logicalcpu)
    osx=1
fi

# Determine what targets to build
if [ "$1" == "" ]; then
    target="mongod mongo mongos"
else
    target=$@
fi

# Enable enterprise modules, if specified
if [ $enterprise -eq 1 ]; then
    ssl=1
    mkdir -p "$moduledir"
    ln -hsf "$enterprisedir" "$moduledir/enterprise"
else
    rm -f "$moduledir/enterprise"
fi

if verlt $version "3.2.0"; then
    # 3.1 and below
    werror=0
    compiler=0
    cache=0
else
    if verlt $version "3.3.0"; then
        # 3.2
        werror=0
    fi

    cache=1
    compiler=1
    if [ $asan -eq 1 ] || [ $osx -eq 1 ]; then
        cc=$clang
        cxx=$clangxx
    else
        cc=$gcc
        cxx=$gxx
    fi
fi

# Set flags corresponding to options
flags="-C$mongodir -j$threads"
if [ $cache -eq 1 ]; then
    flags="$flags --implicit-cache --cache=nolinked --cache-dir=$cachedir"
fi
if [ $compiler -eq 1 ]; then
    flags="$flags CC=$cc CXX=$cxx"
fi
if [ $dynamic -eq 1 ]; then
    flags="$flags --link-model=dynamic"
fi
if [ $verbose -eq 1 ]; then
    flags="$flags --verbose=true"
fi
if [ $ssl -eq 1 ]; then
    flags="$flags --ssl"
fi
if [ $debug -eq 1 ]; then
    flags="$flags --dbg=on --opt=off"
fi
if [ $asan -eq 1 ]; then
    flags="$flags --allocator=system --sanitize=address,leak --llvm-symbolizer=$symbolizer"
fi
if [ $werror -eq 0 ]; then
    flags="$flags --disable-warnings-as-errors"
fi

# Always print actual command to stdout
echo "scons $flags $target"

# Run scons if not in dry run mode
if [ $dryrun -eq 0 ]; then
    nice -n 5 scons $flags $target
fi
